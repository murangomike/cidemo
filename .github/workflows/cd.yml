name: CD Pipeline

on:
  push:
    branches: [ production ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      image_tag:
        description: 'Docker image tag to deploy'
        required: false
        default: 'latest'

env:
  DOCKER_REGISTRY: docker.io
  IMAGE_NAME: murango001/ciddemo
  KUBE_NAMESPACE: crud-app

jobs:
  # Deploy to staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    environment: 
      name: staging
      url: https://crud-app-staging.example.com
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
      continue-on-error: true

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubeconfig for staging
      run: |
        echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > /tmp/kubeconfig
        echo "KUBECONFIG=/tmp/kubeconfig" >> $GITHUB_ENV
      continue-on-error: true

    - name: Update image tag in manifests
      run: |
        IMAGE_TAG=${{ github.event.inputs.image_tag || 'main' }}
        sed -i "s|image: backend-backend:latest|image: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}|g" k8s/backend.yaml

    - name: Deploy to staging
      run: |
        # Apply namespace if it doesn't exist
        kubectl apply -f k8s/namespace.yaml || true
        
        # Deploy PostgreSQL
        kubectl apply -f k8s/postgres.yaml -n ${{ env.KUBE_NAMESPACE }}
        
        # Wait for PostgreSQL to be ready
        kubectl wait --for=condition=ready pod -l app=postgres -n ${{ env.KUBE_NAMESPACE }} --timeout=300s || true
        
        # Deploy backend
        kubectl apply -f k8s/backend.yaml -n ${{ env.KUBE_NAMESPACE }}
        
        # Wait for deployment to complete
        kubectl rollout status deployment/backend -n ${{ env.KUBE_NAMESPACE }} --timeout=600s

    - name: Run smoke tests
      run: |
        # Get the service URL (this would be your actual staging URL)
        echo "Running smoke tests against staging environment..."
        
        # Port forward for testing
        kubectl port-forward service/backend-service 8080:80 -n ${{ env.KUBE_NAMESPACE }} &
        sleep 10
        
        # Test health endpoint
        curl -f http://localhost:8080/healthz || exit 1
        
        # Test users endpoint
        curl -f http://localhost:8080/users || exit 1
        
        echo "Smoke tests passed!"

    - name: Notify staging deployment
      if: always()
      run: |
        if [ $? -eq 0 ]; then
          echo "‚úÖ Staging deployment successful!"
          echo "Environment: https://crud-app-staging.example.com"
        else
          echo "‚ùå Staging deployment failed!"
          exit 1
        fi

  # Deploy to production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    environment: 
      name: production
      url: https://crud-app.example.com
    needs: deploy-staging
    if: github.ref == 'refs/heads/production' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
      continue-on-error: true

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubeconfig for production
      run: |
        echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > /tmp/kubeconfig
        echo "KUBECONFIG=/tmp/kubeconfig" >> $GITHUB_ENV
      continue-on-error: true

    - name: Update image tag in manifests
      run: |
        IMAGE_TAG=${{ github.event.inputs.image_tag || 'production' }}
        sed -i "s|image: backend-backend:latest|image: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}|g" k8s/backend.yaml
        
        # Set production replicas
        sed -i 's|replicas: 3|replicas: 5|g' k8s/backend.yaml

    - name: Deploy to production
      run: |
        # Apply namespace if it doesn't exist
        kubectl apply -f k8s/namespace.yaml || true
        
        # Deploy PostgreSQL
        kubectl apply -f k8s/postgres.yaml -n ${{ env.KUBE_NAMESPACE }}
        
        # Wait for PostgreSQL to be ready
        kubectl wait --for=condition=ready pod -l app=postgres -n ${{ env.KUBE_NAMESPACE }} --timeout=300s || true
        
        # Deploy backend with rolling update
        kubectl apply -f k8s/backend.yaml -n ${{ env.KUBE_NAMESPACE }}
        
        # Apply HPA for production
        kubectl apply -f k8s/hpa.yaml -n ${{ env.KUBE_NAMESPACE }} || true
        
        # Wait for deployment to complete
        kubectl rollout status deployment/backend -n ${{ env.KUBE_NAMESPACE }} --timeout=900s

    - name: Run production health checks
      run: |
        echo "Running production health checks..."
        
        # Port forward for testing
        kubectl port-forward service/backend-service 8080:80 -n ${{ env.KUBE_NAMESPACE }} &
        sleep 15
        
        # Test health endpoint
        for i in {1..5}; do
          if curl -f http://localhost:8080/healthz; then
            echo "Health check $i passed"
          else
            echo "Health check $i failed"
            exit 1
          fi
          sleep 2
        done
        
        # Test users endpoint
        curl -f http://localhost:8080/users || exit 1
        
        echo "Production health checks passed!"

    - name: Create GitHub release
      if: github.ref == 'refs/heads/production'
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ github.run_number }}
        release_name: Release v${{ github.run_number }}
        body: |
          ## üöÄ Production Release v${{ github.run_number }}
          
          **Deployed to Production**: https://crud-app.example.com
          
          **Changes in this release:**
          - Commit: ${{ github.sha }}
          - Branch: ${{ github.ref_name }}
          - Workflow: ${{ github.workflow }}
          
          **Docker Image:** `${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:production`
          
          **Deployment Details:**
          - Environment: Production
          - Replicas: 5
          - HPA Enabled: Yes
          - Database: PostgreSQL 15
        draft: false
        prerelease: false

    - name: Notify production deployment
      if: always()
      run: |
        if [ $? -eq 0 ]; then
          echo "‚úÖ Production deployment successful!"
          echo "Environment: https://crud-app.example.com"
          echo "Release: v${{ github.run_number }}"
        else
          echo "‚ùå Production deployment failed!"
          exit 1
        fi

  # Rollback capability
  rollback:
    name: Rollback Production
    runs-on: ubuntu-latest
    if: failure() && github.ref == 'refs/heads/production'
    needs: deploy-production
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubeconfig for production
      run: |
        echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > /tmp/kubeconfig
        echo "KUBECONFIG=/tmp/kubeconfig" >> $GITHUB_ENV
      continue-on-error: true

    - name: Rollback deployment
      run: |
        echo "Rolling back production deployment..."
        kubectl rollout undo deployment/backend -n ${{ env.KUBE_NAMESPACE }} || true
        kubectl rollout status deployment/backend -n ${{ env.KUBE_NAMESPACE }} --timeout=300s || true
        echo "Rollback completed!"

    - name: Notify rollback
      run: |
        echo "‚ö†Ô∏è Production deployment was rolled back due to failures!"
        echo "Please check the logs and investigate the issues."
